// Generated by CoffeeScript 1.3.3

/*

                            cccccccccccccccccccccc
                       ccccccccccccccccccccccccccccccccc
                   ccccccccccccccccccccccccccccccccccccccccc
                ccccccccccccccccccccccccccccccccccccccccccccccc
             cccccccccccccccccccccccccccccccccccccccccccccccccccc
           cccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      ccccccccccccccccccccccccccccccccccccccccccc     cccccccccccccccccc
     ccccccccccccc           cccccccccccccccc             cccccccccccccccc
    ccccccccccccccccc   ccccccccccccccccccc     cccccccc    ccccccccccccccc
   cccccccccccccccccc   cccccccccccccccccc    cccccccccccc   ccccccccccccccc
  ccccccccccccccccccc   cccccccccccccccccc   cccccccccccccc   cccccccccccccc
 cccccccccccccccccccc   ccccccccccccccccc   ccccccccccccccc   ccccccccccccccc
 cccccccccccccccccccc   cccccccccccccccccc   cccccccccccccc   cccccccccccccccc
ccccccccccccccccccccc   cccccccccc   ccccc    cccccccccccc   ccccccccccccccccc
ccccccccccccccccccccc   cccccccccc   cccccc     cccccccc    cccccccccccccccccc
cccccccccccccccccc                   cccccccc             ccccccccccccccccccccc
cccccccccccccccccccccccccccccccccccccccccccccccccc    ccccccccccccccccccccccccc
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cccccccccccccccccc                 ccccccc                  ccccccccccccccccccc
ccccccccccccccccccccc   ccccccccc    cccccccc   ccccccccc   cccccccccccccccccc
ccccccccccccccccccccc   ccccccccccc  cccccccc   ccccccccc   cccccccccccccccccc
 cccccccccccccccccccc   cccccccccc   cccccccc   cccccccccccccccccccccccccccccc
 cccccccccccccccccccc               ccccccccc        cccccccccccccccccccccccc
  ccccccccccccccccccc   cccc    ccccccccccccc   cccccccccccccccccccccccccccc
   cccccccccccccccccc   ccccc    cccccccccccc   ccccccccc   cccccccccccccccc
    ccccccccccccccccc   ccccccc   ccccccccccc   ccccccccc   ccccccccccccccc
     ccccccccccccc      cccccccc     ccccc                  cccccccccccccc
      cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
           cccccccccccccccccccccccccccccccccccccccccccccccccccccccc
             cccccccccccccccccccccccccccccccccccccccccccccccccccc
                ccccccccccccccccccccccccccccccccccccccccccccccc
                   ccccccccccccccccccccccccccccccccccccccccc
                       ccccccccccccccccccccccccccccccccc
                            cccccccccccccccccccccc


We're hiring awesome people to build awesome things (like this) - http://lore.com/jobs

Developed by: Jim Grandpre (@jimtla)
Designed by: Matt Delbridge (@matt_delbridge), Aaron Carambula (@carambula), Joseph Cohen (@josephcohen)
*/


(function() {
  var Dot, deep_clone, dist2, random;

  (function() {
    var lastTime, vendor, vendors, _i, _len, _ref;
    lastTime = 0;
    vendors = ['ms', 'moz', 'webkit', 'o'];
    for (_i = 0, _len = vendors.length; _i < _len; _i++) {
      vendor = vendors[_i];
      if (window.requestAnimationFrame) {
        break;
      }
      window.requestAnimationFrame = window[vendor + 'RequestAnimationFrame'];
      window.cancelAnimationFrame = (_ref = window[vendors + 'CancelAnimationFrame']) != null ? _ref : window[vendors + 'RequestCancelAnimationFrame'];
    }
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = function(callback) {
        var currTime, id, timeToCall;
        currTime = (new Date).getTime();
        timeToCall = Math.max(0, 16 - (currTime - lastTime));
        id = window.setTimeout((function() {
          return callback(timeToCall);
        }), timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };
    }
    if (!window.cancelAnimationFrame) {
      return window.cancelAnimationFrame = function(id) {
        return clearTimeout(id);
      };
    }
  })();

  dist2 = function(p0, p1) {
    return (p0.x - p1.x) * (p0.x - p1.x) + (p0.y - p1.y) * (p0.y - p1.y);
  };

  random = function() {
    return (Math.random() - 0.5) / 10;
  };

  deep_clone = function(target) {
    var k, res, t, v, _i, _len, _results;
    if (target instanceof Array) {
      _results = [];
      for (_i = 0, _len = target.length; _i < _len; _i++) {
        t = target[_i];
        _results.push(t);
      }
      return _results;
    } else if (typeof target === 'object') {
      res = {};
      for (k in target) {
        v = target[k];
        res[k] = deep_clone(v);
      }
      return res;
    } else {
      return target;
    }
  };

  Dot = (function() {

    function Dot(target, screen) {
      this.target = target;
      this.screen = screen;
      this.target.background_image = null;
      this.actual = deep_clone(this.target);
      this.current_background = null;
      this.velocity = {
        x: 0,
        y: 0
      };
      this.node = $('<div class="dot"><div class="inner-dot"></div></div>');
      this.screen.find('.dots').append(this.node);
      this.inner_node = this.node.find('.inner-dot');
    }

    Dot.prototype.set_goal = function(goal) {
      this.target = _(deep_clone(goal)).defaults(this.target);
      if (!goal.background_image) {
        return this.target.background_image = null;
      }
    };

    Dot.prototype.do_frame = function(scale) {
      var previous;
      previous = deep_clone(this.actual);
      this.animate();
      return this.draw(scale, previous);
    };

    Dot.prototype.animate = function() {
      var abs_dv, c, dcol, dist, dv, dx, dy, i, scalar, speed, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      if (this.target.absolute) {
        return this.actual = deep_clone(this.target);
      } else {
        speed = 0.004;
        this.velocity.x *= 0.9;
        this.velocity.y *= 0.9;
        dx = this.target.position.x - this.actual.position.x;
        dy = this.target.position.y - this.actual.position.y;
        this.velocity.x += dx * speed;
        this.velocity.y += dy * speed;
        this.actual.position.x += this.velocity.x;
        this.actual.position.y += this.velocity.y;
        dcol = (function() {
          var _i, _len, _ref, _results;
          _ref = this.actual.color;
          _results = [];
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            c = _ref[i];
            _results.push(this.target.color[i] - c);
          }
          return _results;
        }).call(this);
        dist = Math.sqrt(dcol[0] * dcol[0] + dcol[1] * dcol[1] + dcol[2] * dcol[2]);
        for (i = _i = 0, _len = dcol.length; _i < _len; i = ++_i) {
          c = dcol[i];
          if (dist > 4) {
            this.actual.color[i] += c / dist * 4;
          } else {
            this.actual.color[i] += c;
          }
        }
        _ref = ['radius', 'opacity', 'outer_opacity', 'outer_padding'];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          scalar = _ref[_j];
          dv = this.target[scalar] - this.actual[scalar];
          abs_dv = Math.abs(dv);
          if (abs_dv > speed) {
            dv = dv / abs_dv * speed;
          }
          this.actual[scalar] += dv;
        }
        this.actual.z_index = this.target.z_index;
        if (this.target.immediate) {
          _ref1 = this.target.immediate;
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            i = _ref1[_k];
            this.actual[i] = this.target[i];
          }
        }
        return this.actual.background_image = deep_clone(this.target.background_image);
      }
    };

    Dot.prototype.draw = function(scale, previous) {
      var act, background, c, color, compute_inner, inner_changed, inner_changes, k, node_changes, outer_radius, posx, posy, prev, v;
      outer_radius = this.actual.radius + this.actual.outer_padding;
      inner_changed = false;
      inner_changes = {};
      compute_inner = {
        top: function(t) {
          return t.outer_padding / 2 * scale;
        },
        left: function(t) {
          return t.outer_padding / 2 * scale;
        },
        width: function(t) {
          return t.radius * scale;
        },
        height: function(t) {
          return t.radius * scale;
        },
        background: function(t) {
          var c, color;
          color = (function() {
            var _i, _len, _ref, _results;
            _ref = t.color;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              c = _ref[_i];
              _results.push(parseInt(c));
            }
            return _results;
          })();
          return "rgba(" + color + "," + t.opacity + ")";
        }
      };
      for (k in compute_inner) {
        v = compute_inner[k];
        prev = v(previous);
        act = v(this.actual);
        if (prev !== act) {
          inner_changed = true;
          inner_changes[k] = act;
        }
      }
      if (inner_changed) {
        this.inner_node.css(inner_changes);
      }
      node_changes = {
        top: (this.actual.position.y - outer_radius / 2) * scale,
        left: (this.actual.position.x - outer_radius / 2) * scale,
        width: (this.actual.radius + this.actual.outer_padding) * scale,
        height: (this.actual.radius + this.actual.outer_padding) * scale,
        'z-index': this.actual.z_index
      };
      if (this.target.background_image == null) {
        color = (function() {
          var _i, _len, _ref, _results;
          _ref = this.actual.color;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            _results.push(parseInt(c));
          }
          return _results;
        }).call(this);
        node_changes.background = "rgba(" + color + "," + this.actual.outer_opacity + ")";
        node_changes.opacity = 1;
        this.current_background = null;
      } else {
        background = this.actual.background_image;
        if (this.current_background !== background.image) {
          node_changes.background = "url(" + background.image + ") no-repeat";
          this.current_background = background.image;
        }
        posx = parseInt((background.position.x - background.size / 2) * scale - node_changes.left);
        posy = parseInt((background.position.y - background.size / 2) * scale - node_changes.top);
        node_changes['background-position'] = "" + posx + "px " + posy + "px";
        node_changes['background-size'] = parseInt(background.size * scale);
        node_changes['-moz-background-size'] = parseInt(background.size * scale);
        node_changes.opacity = this.actual.outer_opacity;
      }
      return this.node.css(node_changes);
    };

    return Dot;

  })();

  $(function() {
    var animated_circle, browser_height, browser_width, ck_logo, ck_logo_shape, ck_logo_start, clump, current_page, current_page_index, decompose_ck, do_frame, dots, first_page_button, frame_count, get_points, i, in_third, infinity, last_below, last_mousewheel, last_page, last_scroll, last_scroll_time, last_sign, lore_logo, make_dot, minor_dimension, new_page, next_page_button, otim, page_count, page_height, pages, point, screen, scroll_momentum, scroll_paused, set_goals, sharing, social, start_time, target_page, text, text_blocks, tree, _i, _len;
    screen = $('.screen');
    console.log($('html').attr('class'));
    ck_logo_start = function() {
      return minor_dimension / 10;
    };
    dots = [];
    make_dot = function(args) {
      var _ref, _ref1, _ref2;
      if ((_ref = args.outer_padding) == null) {
        args.outer_padding = 0;
      }
      if ((_ref1 = args.outer_opacity) == null) {
        args.outer_opacity = 0;
      }
      if ((_ref2 = args.absolute) == null) {
        args.absolute = false;
      }
      return new Dot(args, screen);
    };
    get_points = function(frame_time, dtim, elapsed_time) {
      var s;
      return _.flatten((function() {
        var _i, _len, _ref, _results;
        _ref = current_page.shapes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          s = _ref[_i];
          _results.push(s.get_points(frame_time, dtim, elapsed_time));
        }
        return _results;
      })());
    };
    set_goals = function(points) {
      var i, _base, _base1, _base2, _base3, _base4, _i, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _results;
      _results = [];
      for (i = _i = 0, _ref = points.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if ((_ref1 = (_base = points[i]).z_index) == null) {
          _base.z_index = 1;
        }
        if ((_ref2 = (_base1 = points[i]).outer_padding) == null) {
          _base1.outer_padding = 0;
        }
        if ((_ref3 = (_base2 = points[i]).outer_opacity) == null) {
          _base2.outer_opacity = 0;
        }
        if ((_ref4 = (_base3 = points[i]).absolute) == null) {
          _base3.absolute = false;
        }
        if ((_ref5 = (_base4 = points[i]).immediate) == null) {
          _base4.immediate = [];
        }
        _results.push(dots[i].set_goal(points[i]));
      }
      return _results;
    };
    social = $('.social');
    new_page = function(points) {
      var d, dist, dot, i, mindist, mini, point, these_dots, v, _i, _len, _results;
      if (current_page_index > 1) {
        ck_logo.css({
          opacity: 0
        });
      } else {
        ck_logo.css({
          opacity: 1
        });
      }
      if (current_page_index === pages.length - 1) {
        social.addClass('visible');
        lore_logo.addClass('visible');
        next_page_button.fadeOut(500);
        first_page_button.addClass('visible');
      } else {
        social.removeClass('visible');
        lore_logo.removeClass('visible');
        next_page_button.fadeIn(500);
        first_page_button.removeClass('visible');
      }
      these_dots = _.clone(dots);
      dots = (function() {
        var _i, _j, _len, _len1, _results;
        _results = [];
        for (_i = 0, _len = points.length; _i < _len; _i++) {
          point = points[_i];
          if (these_dots.length > 0) {
            mindist = Infinity;
            mini = -1;
            for (i = _j = 0, _len1 = these_dots.length; _j < _len1; i = ++_j) {
              dot = these_dots[i];
              dist = dist2(dot.actual.position, point.position);
              if (dist < mindist) {
                mindist = dist;
                mini = i;
              }
            }
            d = these_dots[mini];
            v = these_dots.pop();
            if (mini < these_dots.length) {
              these_dots[mini] = v;
            }
            _results.push(d);
          } else {
            _results.push(make_dot(point));
          }
        }
        return _results;
      })();
      _results = [];
      for (_i = 0, _len = these_dots.length; _i < _len; _i++) {
        dot = these_dots[_i];
        dots.push(dot);
        _results.push(dot.set_goal({
          opacity: 0,
          radius: 0,
          outer_padding: 0,
          outer_opacity: 0
        }));
      }
      return _results;
    };
    ck_logo_shape = function() {
      return {
        get_points: function(time, dtim, elapsed_time) {
          ck_logo.css({
            top: Math.min((elapsed_time - 1000) / 200, 1) * ck_logo_start()
          });
          return [];
        }
      };
    };
    decompose_ck = function() {
      var dot_count, dot_radius, final_color, immediate, position, radius, start_colors;
      radius = 0.15;
      dot_count = 20;
      dot_radius = 0.08;
      start_colors = [[74, 39, 62], [54, 125, 186], [54, 125, 186], [93, 141, 72], [239, 158, 24], [191, 41, 36]];
      final_color = [114, 84, 105];
      position = {
        x: 0.5,
        y: 0.5
      };
      immediate = [];
      return {
        get_points: function(time, dtim, elapsed_time) {
          var ang, grid, grid_ind, i, logo_position, p, size, v, _i, _results;
          if (elapsed_time === 0) {
            immediate = (function() {
              var _i, _results;
              _results = [];
              for (i = _i = 0; 0 <= dot_count ? _i < dot_count : _i > dot_count; i = 0 <= dot_count ? ++_i : --_i) {
                _results.push(true);
              }
              return _results;
            })();
          }
          _.defer(function() {
            return ck_logo.css({
              opacity: 0
            });
          });
          logo_position = {
            x: 0.5,
            y: (ck_logo_start() + ck_logo.height() / 2 - 15) / minor_dimension
          };
          _results = [];
          for (p = _i = 0; 0 <= dot_count ? _i < dot_count : _i > dot_count; p = 0 <= dot_count ? ++_i : --_i) {
            ang = 2 * Math.PI * p / 6;
            if (p * 150 + (p % 7) * 100 < elapsed_time - 800) {
              _results.push({
                position: {
                  x: position.x + radius * Math.cos(ang) + random() * 0.3,
                  y: position.y + radius * Math.sin(ang) + random() * 0.3
                },
                color: final_color,
                radius: dot_radius,
                opacity: 1
              });
            } else if (p * 50 < elapsed_time - 700) {
              v = {
                position: {
                  x: position.x + radius * Math.cos(ang) * 2 + random(),
                  y: position.y + radius * Math.sin(ang) * 2 + random()
                },
                color: start_colors[p % start_colors.length],
                radius: dot_radius * 0.3,
                opacity: 0.5 + random()
              };
              if (immediate[p]) {
                v.immediate = ['opacity', 'color'];
                immediate[p] = false;
              } else {
                v.immediate = [];
              }
              _results.push(v);
            } else if (p * 50 < elapsed_time - 100) {
              size = 0.15;
              grid = 4;
              grid_ind = (p * 13) % 20;
              _results.push({
                position: {
                  x: logo_position.x + (grid_ind % grid) * size / (grid - 1) - size / 2,
                  y: logo_position.y + (parseInt(grid_ind / grid)) * size / (dot_count / grid - 1) - size / 2
                },
                color: [255, 255, 255],
                radius: dot_radius * 0.4,
                opacity: 0,
                outer_opacity: 0.1,
                background_image: {
                  position: logo_position,
                  size: size,
                  image: '/microsite_static/coursekit_logo.png'
                }
              });
            } else {
              size = 0.15;
              grid = 4;
              grid_ind = (p * 13) % 20;
              _results.push({
                position: {
                  x: logo_position.x + (grid_ind % grid) * size / (grid - 1) - size / 2,
                  y: logo_position.y + (parseInt(grid_ind / grid)) * size / (dot_count / grid - 1) - size / 2
                },
                color: [255, 255, 255],
                radius: size / dot_count * 10,
                opacity: 0,
                outer_opacity: 1,
                absolute: true,
                background_image: {
                  position: logo_position,
                  size: size,
                  image: '/microsite_static/coursekit_logo.png'
                }
              });
            }
          }
          return _results;
        }
      };
    };
    clump = function(clump_position, size, color, radius, clump_max_radius, orbit_variance, grow, background, rotation_rate) {
      var make_points, opacity, outer_opacity, points;
      if (color == null) {
        color = [84, 147, 195];
      }
      if (size == null) {
        size = 7;
      }
      if (radius == null) {
        radius = {
          constant: 0.01,
          variance: 150
        };
      }
      if (clump_max_radius == null) {
        clump_max_radius = 999;
      }
      if (orbit_variance == null) {
        orbit_variance = 0.014;
      }
      if (grow == null) {
        grow = false;
      }
      if (rotation_rate == null) {
        rotation_rate = 1;
      }
      outer_opacity = 0.8;
      opacity = 0.8;
      if (background != null) {
        opacity = 0;
      }
      points = [];
      make_points = function() {
        var i, r, radius_seed;
        return points = (function() {
          var _i, _results;
          _results = [];
          for (i = _i = 0; 0 <= size ? _i < size : _i > size; i = 0 <= size ? ++_i : --_i) {
            radius_seed = Math.random() / 10;
            r = radius_seed * radius_seed * radius_seed * radius.variance + radius.constant;
            _results.push({
              ang: 2 * Math.PI * i / size + random(),
              velocity: random() * rotation_rate,
              orbitx: Math.min(Math.sqrt(Math.random() * orbit_variance) + r, clump_max_radius) - r,
              orbity: Math.min(Math.sqrt(Math.random() * orbit_variance) + r, clump_max_radius) - r,
              color: color,
              radius: r,
              background_image: background,
              opacity: opacity * (Math.random() * 0.5 + 0.5),
              outer_opacity: outer_opacity * (Math.random() * 0.5 + 0.5)
            });
          }
          return _results;
        })();
      };
      return {
        get_points: function(time, dtim, elapsed_time) {
          var ind, p, _i, _len, _results;
          if (elapsed_time === 0) {
            make_points();
          }
          _results = [];
          for (ind = _i = 0, _len = points.length; _i < _len; ind = ++_i) {
            p = points[ind];
            p.ang += dtim / 8 * p.velocity;
            if (elapsed_time > 3200 && grow) {
              if (ind > 0) {
                p.outer_opacity -= 0.01;
              } else {
                if (p.radius < 0.32) {
                  p.radius += 0.2;
                }
                p.orbitx -= 0.1;
                p.orbity -= 0.1;
                p.orbitx = Math.max(0, p.orbitx);
                p.orbity = Math.max(0, p.orbity);
                if (elapsed_time > 4000) {
                  p.outer_opacity += 0.005;
                } else {
                  p.outer_opacity = 0.2;
                }
              }
            } else {
              p.orbitx += random() / 100;
              p.orbity += random() / 100;
            }
            if (grow && p.radius < 0.15 && time % 4 === 0) {
              p.radius += Math.random() / 1e3;
            }
            p.position = {
              x: clump_position.x + p.orbitx * Math.cos(p.ang),
              y: clump_position.y + p.orbity * Math.sin(p.ang)
            };
            _results.push(p);
          }
          return _results;
        }
      };
    };
    sharing = function(position) {
      var color, i, moving_points, opacity, pin_offsets, pins, radius, size;
      radius = 0.4;
      pins = 3;
      color = [122, 161, 106];
      opacity = 0.7;
      size = 18;
      moving_points = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= size ? _i < size : _i > size; i = 0 <= size ? ++_i : --_i) {
          _results.push({
            ang: 2 * Math.PI * i / size + random(),
            velocity: Math.sqrt(Math.random() + 0.2) * 0.015 * (random() > 0 ? 1 : -1),
            orbit: random() + radius,
            color: color,
            radius: (.1 + random()) * 0.3,
            opacity: opacity + random() * 5,
            'z-index': random() > 0 ? 60 : 40
          });
        }
        return _results;
      })();
      pin_offsets = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= pins ? _i < pins : _i > pins; i = 0 <= pins ? ++_i : --_i) {
          _results.push({
            x: 0,
            y: 0
          });
        }
        return _results;
      })();
      return {
        get_points: function(time, dtim, elapsed_time) {
          var ang, distance, near_pin, p, points, _i, _j, _len;
          points = [];
          for (p = _i = 0; 0 <= pins ? _i < pins : _i > pins; p = 0 <= pins ? ++_i : --_i) {
            ang = 2 * Math.PI * p / pins - Math.PI / 32;
            pin_offsets[p].x += random() / 10;
            pin_offsets[p].y += random() / 10;
            pin_offsets[p].x *= 0.8;
            pin_offsets[p].y *= 0.8;
            points.push({
              opacity: 1,
              outer_opacity: 1,
              radius: 0.2,
              position: {
                x: Math.cos(ang) * radius + position.x + pin_offsets[p].x,
                y: Math.sin(ang) * radius + position.y + pin_offsets[p].y
              },
              color: color
            });
          }
          for (i = _j = 0, _len = moving_points.length; _j < _len; i = ++_j) {
            p = moving_points[i];
            near_pin = ((p.ang % (2 * Math.PI)) + Math.PI / 32) / (2 * Math.PI) * pins;
            ang = (elapsed_time + 5000 * i / moving_points.length) > 5500 ? (p.opacity += random() * 0.2, distance = Math.abs(Math.abs(near_pin - parseInt(near_pin)) - 0.5) * 4, p.ang += dtim / 10 * p.velocity * 0.8 / (distance * distance * distance + 0.1), p.ang) : parseInt(near_pin) / pins * 2 * Math.PI - Math.PI / 32;
            p.position = {
              x: position.x + p.orbit * Math.cos(ang),
              y: position.y + p.orbit * Math.sin(ang)
            };
            points.push(p);
          }
          return points;
        }
      };
    };
    infinity = function(center) {
      var color, dot_radius, generate_points, opacity, points, radius, size;
      radius = 0.2;
      color = [236, 156, 39];
      opacity = 0.8;
      dot_radius = 0.1;
      size = 21;
      points = [];
      generate_points = function() {
        var i, _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= size ? _i < size : _i > size; i = 0 <= size ? ++_i : --_i) {
          _results.push({
            ang: 4 * Math.PI * i / size,
            color: color,
            radius: (.1 + random()) * 0.3,
            opacity: opacity + random() * 2
          });
        }
        return _results;
      };
      return {
        get_points: function(time, dtim, elapsed_time) {
          var ang, i, offset, p, _i, _len, _results;
          if (elapsed_time === 0) {
            points = generate_points();
          }
          _results = [];
          for (i = _i = 0, _len = points.length; _i < _len; i = ++_i) {
            p = points[i];
            offset = p.ang > 2 * Math.PI ? (ang = -(2 * Math.PI - p.ang) + Math.PI, radius) : (ang = -p.ang, -radius);
            p.position = {
              x: center.x + radius * Math.cos(ang) + offset,
              y: center.y + radius * Math.sin(ang)
            };
            p.ang += dtim / 500;
            p.ang %= Math.PI * 4;
            _results.push(p);
          }
          return _results;
        }
      };
    };
    animated_circle = function(_arg) {
      var color, dot_radius, duration, end, generate_points, max_dots, opacity, outer_opacity, outer_padding, points, radius, rotation, size, start;
      duration = _arg.duration, size = _arg.size, radius = _arg.radius, start = _arg.start, end = _arg.end, rotation = _arg.rotation, dot_radius = _arg.dot_radius, color = _arg.color, opacity = _arg.opacity, outer_padding = _arg.outer_padding, outer_opacity = _arg.outer_opacity;
      max_dots = 6;
      if (color == null) {
        color = [236, 156, 39];
      }
      if (opacity == null) {
        opacity = 0.8;
      }
      if (duration == null) {
        duration = 1000;
      }
      if (outer_padding == null) {
        outer_padding = 0;
      }
      if (outer_opacity == null) {
        outer_opacity = 0;
      }
      points = [];
      generate_points = function() {
        var i, _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= size ? _i < size : _i > size; i = 0 <= size ? ++_i : --_i) {
          _results.push({
            ang: 2 * Math.PI * i / size,
            color: color,
            radius: dot_radius,
            opacity: opacity + random() * 2,
            outer_padding: outer_padding,
            outer_opacity: outer_opacity
          });
        }
        return _results;
      };
      return {
        get_points: function(time, dtim, elapsed_time) {
          var i, p, t, _i, _len, _results;
          if (elapsed_time === 0) {
            points = generate_points();
          }
          t = Math.max(Math.min(elapsed_time / duration, 1), 0);
          _results = [];
          for (i = _i = 0, _len = points.length; _i < _len; i = ++_i) {
            p = points[i];
            p.position = {
              x: (end.x - start.x) * t + start.x + radius * Math.cos(p.ang),
              y: (end.y - start.y) * t + start.y + radius * Math.sin(p.ang)
            };
            p.ang += dtim / 400 * rotation;
            p.ang %= Math.PI * 4;
            _results.push(p);
          }
          return _results;
        }
      };
    };
    point = function(_arg) {
      var color, dot_radius, opacity, outer_opacity, outer_padding, position, z_index;
      position = _arg.position, dot_radius = _arg.dot_radius, color = _arg.color, opacity = _arg.opacity, outer_padding = _arg.outer_padding, outer_opacity = _arg.outer_opacity, z_index = _arg.z_index;
      if (color == null) {
        color = [236, 156, 39];
      }
      if (opacity == null) {
        opacity = 0.8;
      }
      if (outer_padding == null) {
        outer_padding = 0;
      }
      if (outer_opacity == null) {
        outer_opacity = 0;
      }
      if (z_index == null) {
        z_index = 1;
      }
      return {
        get_points: function(time, dtim, elapsed_time) {
          return {
            color: color,
            radius: dot_radius,
            opacity: opacity,
            position: position,
            outer_opacity: outer_opacity,
            outer_padding: outer_padding,
            z_index: z_index
          };
        }
      };
    };
    tree = function() {
      var color, initialize_child, num_dots, out_points, outer_opacity, outer_padding, points, reset_points, split_time;
      num_dots = 42;
      color = [230, 109, 37];
      outer_padding = 0.01;
      outer_opacity = 0.1;
      split_time = function(time, level) {
        return time + 200 + Math.random() * 1000 * Math.sqrt(level);
      };
      points = null;
      out_points = null;
      reset_points = function(time) {
        var np, p, _i, _results;
        out_points = [];
        points = [];
        points.push({
          color: color,
          radius: 0.08,
          opacity: 1,
          outer_padding: outer_padding,
          outer_opacity: outer_opacity,
          position: {
            x: 0.5,
            y: 0.2
          },
          children: [],
          split_time: split_time(time, 1),
          level: 1
        });
        out_points.push(points[0]);
        _results = [];
        for (p = _i = 1; 1 <= num_dots ? _i < num_dots : _i > num_dots; p = 1 <= num_dots ? ++_i : --_i) {
          np = deep_clone(points[0]);
          np.radius = 0.01;
          np.opacity = 0.1;
          np.children = [];
          points[0].children.push(np);
          _results.push(out_points.push(np));
        }
        return _results;
      };
      initialize_child = function(time, parent, child, pivot, left) {
        var c, _i, _len, _ref;
        child.level = parent.level + 1;
        child.position = {
          x: parent.position.x + (Math.random() * 0.3 + 0.7) * (left ? -1 : 1) / (child.level * child.level),
          y: parent.position.y + 0.08 + Math.random() * 0.08
        };
        child.split_time = split_time(time, child.level);
        child.children = left ? parent.children.slice(1, pivot) : parent.children.slice(pivot + 1);
        child.radius = (.08 + random()) / Math.sqrt(child.level);
        child.opacity = .8 + random();
        _ref = child.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          c.position = child.position;
        }
        return points.push(child);
      };
      return {
        get_points: function(time, dtim, elapsed_time) {
          var l, p, _i, _len;
          if (elapsed_time === 0) {
            reset_points(time);
          }
          for (_i = 0, _len = points.length; _i < _len; _i++) {
            p = points[_i];
            p.position.x += random() * 0.08;
            p.position.y += random() * 0.08;
            if (p.split_time < time && p.children.length >= 2) {
              l = parseInt(p.children.length / 2);
              initialize_child(time, p, p.children[0], l, true);
              initialize_child(time, p, p.children[l], l, false);
              p.children = [];
            }
          }
          return out_points;
        }
      };
    };
    pages = [
      {
        shapes: [ck_logo_shape()],
        text: '<span class="smaller"><b>Coursekit is now Lore.<br>Same Company, New Name.</b><br>This is why we made the change.</span>'
      }, {
        shapes: [decompose_ck()],
        text: 'Coursekit started<br>as a toolkit for<br>courses.'
      }, {
        shapes: [
          clump({
            x: 0.4,
            y: 0.7
          }), clump({
            x: 0.1,
            y: 0.3
          }), clump({
            x: 0.8,
            y: 0.4
          })
        ],
        text: 'Courses became<br>communities of<br>learners.'
      }, {
        shapes: [
          sharing({
            x: 0.5,
            y: 0.5
          })
        ],
        text: 'We&rsquo;ve seen<br>that people learn<br>by sharing.'
      }, {
        shapes: [
          infinity({
            x: 0.5,
            y: 0.5
          })
        ],
        text: 'Our mission is to<br>connect the world&rsquo;s<br>learners and<br>educators.'
      }, {
        shapes: [
          animated_circle({
            size: 10,
            radius: 0.06,
            start: {
              x: 0.3,
              y: 0.5
            },
            end: {
              x: 0.5,
              y: 0.5
            },
            dot_radius: 0.02,
            rotation: -1
          }), animated_circle({
            size: 10,
            radius: 0.12,
            start: {
              x: 0.7,
              y: 0.5
            },
            end: {
              x: 0.5,
              y: 0.5
            },
            dot_radius: 0.03,
            rotation: 1
          }), point({
            position: {
              x: 0.5,
              y: 0.5
            },
            dot_radius: 0.03
          })
        ],
        text: 'We need a name<br>that reflects our<br>ambitions.'
      }, {
        shapes: [tree()],
        text: 'Lore means<br>knowledge shared<br>between people.'
      }, {
        shapes: [
          clump({
            x: 0.5,
            y: 0.5
          }, 42, [225, 15, 23], {
            constant: 0.03,
            variance: 50
          }, 0.4, 0.06)
        ],
        text: "That&rsquo;s what we<br>are about."
      }, {
        shapes: [
          clump({
            x: 0.5,
            y: 0.5
          }, 42, [225, 15, 23], {
            constant: 0.04,
            variance: 50
          }, 0.4, 0.04, true, {
            image: '/microsite_static/lore_logo.png',
            position: {
              x: 0.5,
              y: 0.5
            },
            size: 0.3
          }, 0.3)
        ],
        text: ""
      }
    ];
    last_page = null;
    current_page_index = 0;
    current_page = pages[current_page_index];
    page_count = pages.length;
    text_blocks = [];
    for (i = _i = 0, _len = pages.length; _i < _len; i = ++_i) {
      text = pages[i].text;
      text_blocks.push({
        node: $("<span class='caption'>" + text + "</span>").appendTo(screen),
        position: i
      });
    }
    browser_height = 0;
    browser_width = 0;
    minor_dimension = 0;
    ck_logo = screen.find('.coursekit-logo');
    lore_logo = screen.find('.lore-logo');
    page_height = 0;
    $(window).resize(function() {
      var aspect, holder, logo, logos, scale, width, _j, _len1, _ref;
      browser_height = $(window).height();
      page_height = browser_height * 5;
      browser_width = $(window).width();
      minor_dimension = Math.min(browser_width, browser_height);
      screen.width(minor_dimension);
      screen.height(minor_dimension);
      screen.css({
        top: (browser_height - minor_dimension) / 2
      });
      screen.find('.caption').css({
        'font-size': Math.min(minor_dimension / 12, 85),
        left: 0.1 * minor_dimension
      });
      screen.find('.smaller').css({
        'font-size': Math.min(minor_dimension / 20, 60)
      });
      holder = $('.holder');
      holder.height(page_height * page_count - page_height + browser_height - 100);
      logos = [
        {
          logo: ck_logo,
          aspect: 329 / 380,
          scale: 0.15
        }, {
          logo: lore_logo,
          aspect: 1,
          scale: 0.3
        }
      ];
      for (_j = 0, _len1 = logos.length; _j < _len1; _j++) {
        _ref = logos[_j], logo = _ref.logo, aspect = _ref.aspect, scale = _ref.scale;
        width = minor_dimension * scale;
        logo.css({
          width: width,
          height: minor_dimension * scale / aspect,
          left: minor_dimension / 2 - width / 2
        });
      }
      return lore_logo.css({
        top: minor_dimension / 2 - lore_logo.height() / 2
      });
    });
    $(window).resize();
    scroll_momentum = 0;
    last_scroll = $(window).scrollTop();
    last_scroll_time = 0;
    in_third = false;
    $(window).scroll(function(e, triggered) {
      var current_page_height, diff, node, portion, position, scroll_top, sign, target, _j, _len1, _ref;
      scroll_top = $(window).scrollTop();
      current_page_height = page_height * current_page_index;
      portion = page_height / 3;
      if (scroll_top > current_page_height + 2 * portion && (pages[current_page_index + 1] != null)) {
        in_third = false;
      } else if (scroll_top < current_page_height - 2 * portion && (pages[current_page_index + 1] != null)) {
        in_third = false;
      }
      if (scroll_top > current_page_height + portion && (pages[current_page_index + 1] != null)) {
        if (!in_third) {
          current_page_index++;
          current_page = pages[current_page_index];
          in_third = true;
        }
      } else if (scroll_top < current_page_height - portion && (pages[current_page_index - 1] != null)) {
        if (!in_third) {
          --current_page_index;
          current_page = pages[current_page_index];
          in_third = true;
        }
      } else {
        in_third = false;
      }
      for (_j = 0, _len1 = text_blocks.length; _j < _len1; _j++) {
        _ref = text_blocks[_j], node = _ref.node, position = _ref.position;
        target = page_height * position - node.height() / 3;
        diff = (target - scroll_top) * 0.7 / page_height;
        sign = diff > 0 ? 1 : -1;
        node.css({
          top: diff * diff * sign * page_height + minor_dimension / 3
        });
      }
      return last_scroll = scroll_top;
    });
    target_page = 0;
    last_mousewheel = 0;
    $(window).bind('mousewheel', function(e, delta) {
      var momentum, now, scroll_top;
      console.log(delta);
      now = +(new Date);
      if (now - last_mousewheel < 1500 || Math.abs(delta) < 0.4) {
        return;
      }
      last_mousewheel = now;
      momentum = 0.8;
      scroll_top = $(window).scrollTop();
      if (delta > 0) {
        target_page = parseInt(scroll_top / page_height + 0.5) - 1;
      } else {
        target_page = parseInt(scroll_top / page_height + 0.5) + 1;
      }
      return last_scroll_time = +(new Date);
    });
    $(window).scroll();
    next_page_button = screen.find('.next-page').click(function() {
      var scroll_top;
      scroll_top = $(window).scrollTop();
      target_page = parseInt(scroll_top / page_height + 0.5) + 1;
      return false;
    });
    first_page_button = screen.find('.first-page').click(function() {
      target_page = 0;
      return false;
    });
    screen.click(function() {
      var scroll_top;
      scroll_top = $(window).scrollTop();
      return target_page = parseInt(scroll_top / page_height + 0.5) + 1;
    });
    $(document).bind('keydown', function(e) {
      var scroll_top, _ref, _ref1;
      scroll_top = $(window).scrollTop();
      if ((_ref = e.which) === 37 || _ref === 38) {
        target_page = parseInt(sroll_top / page_height + 0.5) - 1;
      } else if ((_ref1 = e.which) === 39 || _ref1 === 40 || _ref1 === 32 || _ref1 === 13 || _ref1 === 9) {
        target_page = parseInt(scroll_top / page_height + 0.5) + 1;
      }
      return false;
    });
    frame_count = 0;
    otim = +(new Date);
    start_time = null;
    last_below = null;
    scroll_paused = 0;
    last_sign = null;
    return requestAnimationFrame(do_frame = function() {
      var closest_below, d, diff, direction, distance_to_target, dtim, sign, time, _j, _len1;
      frame_count++;
      time = +(new Date);
      dtim = time - otim;
      otim = time;
      if (scroll_paused + 100 > time) {
        scroll_momentum = 0;
      }
      if (frame_count % 1 === 0) {
        last_scroll = $(window).scrollTop();
        direction = scroll_momentum > 0 ? 1 : -1;
        distance_to_target = target_page - last_scroll / page_height;
        sign = scroll_momentum / Math.abs(scroll_momentum);
        last_sign = sign;
        closest_below = parseInt(last_scroll / page_height);
        scroll_momentum += distance_to_target * 0.08;
        if ((last_below != null) && last_below !== closest_below) {
          scroll_momentum = 0;
          scroll_paused = time;
        }
        last_below = closest_below;
        scroll_momentum /= 2;
        diff = scroll_momentum * browser_height * browser_height / 500;
        if (parseInt(Math.abs(diff)) > 0) {
          $(window).scrollTop(last_scroll + diff);
        }
      }
      if (current_page !== last_page) {
        start_time = time;
        new_page(get_points(time, dtim, start_time - time));
      }
      set_goals(get_points(time, dtim, time - start_time));
      for (_j = 0, _len1 = dots.length; _j < _len1; _j++) {
        d = dots[_j];
        d.do_frame(Math.min(browser_height, browser_width));
      }
      last_page = current_page;
      return requestAnimationFrame(do_frame);
    });
  });

}).call(this);
